<script src=lib2_2.js></script>

<body bgcolor=black>
<center>
<td><canvas id='canvas1' width=400 height=400></canvas></td>
</center>
</body>

<script>

   // IMPLEMENT A VECTOR NORMALIZE FUNCTION IN JAVASCRIPT.

   function normalize(vec) {
      var norm = Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2]);
      for (var i = 0 ; i < 3 ; i++)
         vec[i] /= norm;
   }

   // SPECIFY HOW MANY LIGHT SOURCES FOR THE FRAGMENT SHADER TO LOOP THROUGH.

   var nLights = 2;

   // MAINTAIN AN ARRAY OF LIGHT DIRECTION VALUES.

   var lDirValues;
   var lColorValues = 
   [
      .6, .6, 1.,
      .15, .15, .06
   ];

   var ambient = 
   [
      .5, .2, .9,
      .0, .0, .0
   ];
   var diffuse = [.9, .9, .9];
   var specular = [.40, .34, .11];
   var specPower = 16;
   // A TEST VARIABLE, JUST FOR PRACTICING DECLARING AND SETTING UNIFORM SHADER VARIABLES.

   var testValue = 0;

   // UPDATE FUNCTION IS CALLED BY THE LIBRARY BEFORE RENDERING, ONCE PER ANIMATION FRAME.

   var nSpheres = 2;
   var coordSpheres = 
   [
      .2, -.5, -4, .93,
      0., 0., -3., .35
   ];

   var update = function() {

      // AT EACH ANIMATION FRAME, COMPUTE THE LIGHT DIRECTIONS.

      var x = Math.sin(Math.PI * time);

      var lDir0 = [x,.7,1];
      var lDir1 = [-1,-1,-1];
      normalize(lDir0);
      normalize(lDir1);

      lDirValues = [];
      lDirValues.push(lDir0[0], lDir0[1], lDir0[2]);
      lDirValues.push(lDir1[0], lDir1[1], lDir1[2]);

      // THIS IS JUST A TEST VALUE THAT WE CREATED FOR PRACTICE.

      testValue = .5 + .5 * Math.sin(2 * time);
   }
</script>

<script id='my_vertex_shader' type='x-shader/x-vertex'>
   attribute vec3 aPosition;
   varying   vec3 vPosition;
   void main() {
      gl_Position = vec4(aPosition, 1.0);
      vPosition = aPosition;
   }
</script>

<script id='my_fragment_shader' type='x-shader/x-fragment'>

// change things to uniform variables!!!!


   precision mediump float;
   uniform vec3  uCursor;
   uniform vec3  uLDir[20];  // WE ADDED THIS UNIFORM
   uniform float uTest;      // WE ADDED THIS UNIFORM
   uniform float uTime;
   uniform int   uNLights;   // WE ADDED THIS UNIFORM
   uniform vec4  uSpheres[5];
   uniform int   uNSpheres;
   uniform vec3  uLColor[20];// Color value of lights
   uniform vec3  uAmbient[20];   // Ambient color value
   uniform vec3  uDiffuse;   // Diffuse color value
   uniform vec3  uSpecular;  // Specular color value
   uniform float uSpecP;     // Specular Power

   varying vec3  vPosition;


   // FOR EXTRA CREDIT: IMPLEMENT MULTIPLE SPHERES.

   vec4 sphere;

   // ambient AND diffuse, BELOW, ARE SUFFICIENT TO CREATE ONLY DIFFUSE MATERIALS.

   // YOU NEED TO ADD specular AND power TO IMPLEMENT THE PHONG SHADING ALGORITHM.
   // FOR EXTRA CREDIT, YOU CAN MAKE THESE ARRAYS TO IMPLEMENT MULTIPLE MATERIALS.

   // vec3 ambient;
   // vec3 diffuse;

   vec3 lColor[2];

   // COMPUTE THE INTERSECTION OF A RAY WITH A SPHERE, IF ANY.

   float raySphere(vec3 V, vec3 W, vec4 sph) {
      vec3 D = V - sph.xyz;
      float b = 2. * dot(W, D);
      float c = dot(D, D) - sph.w * sph.w;
      float discr = b * b - 4. * c;
      return discr >= 0. ? (-b - sqrt(discr)) / 2. : 10000.;
   }

   float castShadow(vec3 V, vec3 W){
      float t = -1.;
      for (int k = 0; k < 20; k++){
         if (k < uNSpheres){
            t = raySphere(V, W, uSpheres[k]);
            if (t < 10000. && t > 0.){
               return 500.;
            }
         }
      }
      return 10000.0;
   }

   // vec3 castReflection(vec3 V, vec3 W){
   //    float t = 10000.;
   //    vec4 nearSphere;
   //    vec3 nearSphereAmbient;
   //    for (int k = 0; k < 20; k++){
   //       if (k < uNSpheres){
   //          float temp = raySphere(V, W, uSpheres[k]);
   //          if (temp < t){
   //             t = temp;
   //             nearSphere = uSpheres[k];
   //             nearSphereAmbient = uAmbient[k];
   //          }
   //       }
   //    }
   //    if (t < 10000. && t > 0.){
   //       //getting error here....
   //       vec3 color = shadeSphere(V + t * W, nearSphere, W, nearSphereAmbient);
   //       return color;
   //       // return vec3(1., 1., 1.);
   //    }
   //    return vec3(1., 1., 1.);
   // }

   /*
   vec3 castRefraction(float n1, float n2, vec3 W){
      1. find theta2 and bend light by that
      2. continue ray tracing inside of sphere until you hit the other side of the sphere
      3. compute where it exits the sphere using the second root of the quadratic equation (changing minus to plus)
      4. compute how much it refracts on the way out of the sphere
      5. shoot ray beyond to see what it hits
   }
   */

   vec3 castRefraction(float n1, float n2, vec3 W /* direction of light */, vec3 norm){
      // find theta2
      float cos = dot(W, norm) / (length(W) * length(norm));
      float theta2 = acos(radians(cos));
      // is this even right?

      return vec3(1., 1., 1.);
   }


   /*

   In the real world many materials, such as oil, water, plastic, glass and diamond, are transparent. A transparent material has an index of refraction which measures how much light slows down as it enters that medium. For example, the index of refraction of water is about 1.333, of glass is about 1.5. The index of refraction of diamond, the substance with the highest known index of refraction, is 2.42.
As in the diagram to the right, you can add refraction to your ray tracing by following Snell's law:

n1 / n2 = sin(θ2) / sin(θ1)
to determine how much the ray should bend as it enters or exits a transparent object.
Note that you will need to change your ray tracing model to incorporate refraction. In addition to your initial incoming ray, and any shadow or reflection rays, you also need to add a refraction ray, which starts just inside the surface, and continues inward.

Note that if you have ray traced to a sphere, and are now computing where the refracting ray will exit that sphere, you will want to compute the second root of the quadratic equation.

Then, after this refracting ray has exited out the back of the transparent sphere, you will want to compute how much it refracts on its way out, and then shoot a ray from there into the scene behind the sphere.

In general, you use the results of refraction by mixing the color it returns together with whatever surface color you have computed due to pure reflection or blinn/phong reflectance.


   */


   vec3 shadeSphere(vec3 point, vec4 sphere, vec3 W, vec3 ambient) {
      vec3 normal = (point - sphere.xyz) / sphere.w;
      vec3 shade = ambient;
      vec3 specular = vec3(.40, .34, .11);
      // float p = 1.;

      // LOOP THROUGH THE FIRST uNlights LIGHT SOURCES.

      for (int i = 0 ; i < 20 ; i++){
         if (i < uNLights){

            //look for shadow
            float t = 10000.;
            // t = raySphere(point + .001 * uLDir[i], uLDir[i], sphere); //needs to check every other sphere
            t = castShadow(point + .001 * uLDir[i], uLDir[i]);
            
            if (t > 9996.){ //if it misses an object
               vec3 E = -W;
               vec3 R = 2. * (dot(normal, uLDir[i]) * normal) - uLDir[i];
               shade += uDiffuse * max(0., dot(normal, uLDir[i])) * uLColor[i] + uSpecular * max(0., pow(dot(E, R), uSpecP)) * uLColor[i];

               /*then calculate reflection?
                  bounce the light off the normal
                  calculate the base color (diffuse, ambient, specular), then if you have reflective surface, cast out and figure out what light is being reflected and add it to the base color
               */

               vec3 WPrime = 2. * (dot(normal, -W) * normal - (-W));

               /*vec3 reflection = castReflection(point + .001 * WPrime, WPrime);

               shade += reflection;*/


               /*then calculate refraction?
                     have material that the ray continues through - continue to raySphere through until you hit the other side of the sphere, and then refract again
                     When it comes out on the other side it shows the color
                     return to the original point and apply the light from the point that you hit

                  */


            }
            else { //hits object
               // shade += uDiffuse * max(0., dot(normal, uLDir[i])) * uLColor[i] * 0.5; 
               shade *= uDiffuse;
               /*
                  level of ambient light
                  user normal of sphere putting the shadow onto
               */
            }

            

            
            // OLD SHADER CODE
            // shade += lColor[i] * uDiffuse * max(0., dot(normal, uLDir[i]));
            
         }
      }
      return shade;
   }

   void main(void) {
      // now uniform variable
      // lColor[0] = vec3(.6,.6,1.);
      // lColor[1] = vec3(.15,.15,.06);

      // sphere = uSpheres;
      // sphere = vec4(0., 0., -3., .35);

      // ambient = uAmbient;
      // ambient = vec3(.1, .1, .1);
      // diffuse = vec3(.9, .9, .9);

      // COMPUTE V AND W TO CREATE THE RAY FOR THIS PIXEL, USING vPosition.x AND vPosition.y.

      vec3 V = vec3(0., 0., 0.);
      vec3 W = normalize(vec3(vPosition.xy, -3.));

      vec3 color = vec3(.05, .05, .05);         // BACKGROUND COLOR
      float t = 10000.;
      vec4 nearSphere;
      vec3 nearSphereAmbient;
      for (int i = 0; i < 20; i++){
         if (i < uNSpheres){
            float temp = raySphere(V, W, uSpheres[i]);
            if (temp < t){
               t = temp;
               nearSphere = uSpheres[i];
               nearSphereAmbient = uAmbient[i];
            }
         }
      }
      // float t = raySphere(V, W, sphere);
      if (t < 10000.)
         color = shadeSphere(V + t * W, nearSphere, W, nearSphereAmbient);

      // color.r *= uTest; // SEE WHETHER TEST VALUE HAS BEEN PASSED CORRECTLY TO THE FRAGMENT SHADER.

      color = sqrt(color);                   // DO GAMMA CORRECTION.

      gl_FragColor = vec4(color, 1.);        // SET OPACITY TO 1.
   }
</script>

<script>
start_gl('canvas1', document.getElementById('my_vertex_shader'  ).innerHTML,
                    document.getElementById('my_fragment_shader').innerHTML);
</script>


